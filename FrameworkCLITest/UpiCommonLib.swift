//
//  UpiCommonLib.swift
//  
//
//  Created by ShashiTiwari on 30/01/23.
//

//typealias ResponseBlock = ([AnyHashable : Any]?) -> Void

import Foundation
import UIKit
import CommonLibrary

public class UpiCommonLib: NSObject {
    //let clServices = CLServices.self
    
    public static let sharedInstance = UpiCommonLib()
    //    let clservice = clservice()
   // let KEY_CODE = "NPCI"
    let controller: UIViewController = UIViewController()
    //    let upiHelper = UpiHelper()
    
    
    
    /** Returns true if challenge is a valid string.
     @brief Get the challenge (string pointer) with deviceId, appId, type - type may be "Initial" or "Rotate"
     @author NPCI
     @copyright NPCI
     @note getChallengeForDeviceId is called in two modes "Initial" or "Rotate"
     @since library version 1.0
     @todo Initially when the app is launched then the function is called in "Initial" mode then challenge is found that is valid for 30days, after 30 days it is called in "Rotate" mode
     @version 1.5
     @result pointer to string - challenge
     @return BOOL
     @code BOOL success = [CLServices getChallengeForDeviceId:device_id appID: App_id type:@"Initial" challenge:&challenge error:&error]; ////initial
     NSTimeInterval interval = [previous_date timeIntervalSinceNow]; if (interval>2592000) ///interval for 30 days
     {
     BOOL success = [CLServices getChallengeForDeviceId: device_id appID: App_id type:@"Rotate" challenge:&challenge error:&error];
     }
     @params deviceId, appId, type */
    
    /* Steps: 2 : Get challenge
     * Execute `getChallenge` service to receive a challenge from common library.
     * PSP does a RPC to CL and asks for “Challenge” which can be decrypted only by NPCI server
     *
     * Note: For the first time when App with new CL version updated, getChallenge should
     * be called with type 'Initial'.
     *
     * @param deviceId, This is a mandatory parameter specifying the current device id.
     *
     * @param type, This is a mandatory parameter specifying the requirement for getting challenge value.
     * values to be populated- “initial” for registration and “rotate” for rotation
     * @return Sample output: “2.3-v1.8|Challenge
     TODO: Save date of Challenge generated and implemet Rotate Logic
     */
    
    /*
     // TODO: Rotation Logic : Need to check for the previous date logic - From where to get it?
     var previousDate = Date()
     
     success = try clServices.getChallengeForDeviceId(deviceId, appId: appId, type: "Initial", challenge: &challengeString)
     
     let interval = previousDate.timeIntervalSinceNow
     if interval > 2592000 {
     do {
     success = try clServices.getChallengeForDeviceId(deviceId, appId: appId, type: "Rotate", challenge: &challengeString)
     } catch {
     }
     }
     */
    
    /// - Parameters:
    ///  - deviceId: This is a mandatory parameter specifying the current device id.
    ///  - type: This is a mandatory parameter specifying the requirement for getting challenge value. Values to be populated- "initial" for registration and "rotate" for rotation.
    ///  - appId: This is a mandatory parameter specifying the current app id.
    ///  - return: Output of the above service will be a string containing the "Challenge". PSP Mobile app should pass the generated challenge to PSP server to receive a valid token from UPI. If Common Library fails to generate a challenge, the output will return null. CL will also add version along with challenge starting from CL 1.7 version.
    /// Sample output: “2.3-v1.8|Challenge”
    public func getChallenge(deviceId: String, type: String, appId: String) -> String {
        var challengeString: NSString?
        
        do {
            let isChallengeData = try CLServices.getChallengeForDeviceId(deviceId, appId: appId, type: type, challenge: &challengeString)
            
        } catch {
            print("ERROR")
        }
        return challengeString as? String ?? ""
        
    }
    
    /// Register App Service
    /// After receiving a valid token from UPI, PSP mobile app should store it in the application. After which "Register App" service should be executed to validate the token and register the PSP app.
    
    
    /** Returns true if hmac is valid with respect of appid, mobile, deviceID.
     @brief validation of hmac (generated with appId, mobile number, deviceID hash) with the actual parameters
     @author NPCI
     @copyright NPCI
     @note registerAppWithHmac is called with hmac generated by app with deviceId, appId and mobile number
     @since library version 1.0
     @version 1.5
     @result BOOL - hmac is valid against provided appid, mobile, deviceId.
     @return BOOL
     @code BOOL success_register= [CLServices registerAppWithHmac:hmac appID: App_id mobile:mobile_number deviceID: device_id error:&register_error];
     @params hmac, appId, mobile, deviceId
     */
    
    /// - Parameters:
    ///  - appId: This is a mandatory parameter for specifying the current app id.
    ///  - deviceid: This is a mandatory parameter for specifying the current device id.
    ///  - keyToken: This is a mandatory parameter specifying the current app id.
    ///  - mobile: This is a mandatory parameter for specifying the mobile number of the user which needs to be verified by the PSP app.
    
    public func register(appId: String, deviceid: String, keyToken: String, mobile: String) -> Bool {
        var isRegistered: Bool?
        let randomString = RANDOM().random()
        let hash =  HMAC().populateHMAC(appId, mobile, keyToken, deviceid, randomString)
        var errorId: NSError?
        isRegistered = CLServices.registerApp(withHmac: hash, appID: appId, mobile: mobile, deviceID: deviceid, error: &errorId , random: randomString)
        return isRegistered!
    }
    
    /*
     * The psp initiates “Get Credential” service of CL to get all the trusted values
     *
     * @param keyCode, This is a mandatory parameter specifying NPCI or UIDAI public key is being used.
     * valid values can be NPCI or UIDAI.
     */
    public func getCredentials(keyCode: String, clReqParam: CLRequestParams) -> Bool {
        let isCredentials: Bool = true
        
        let control = getCredBlocksControl(clRequestParams: clReqParam)
        let xmlPayload = clReqParam.listKeysXmlPayload
        let configuration = getConfigurationParam(clRequestParams: clReqParam)
        let salt = getSaltParamString(clRequestParams: clReqParam)
        let payInfo = getPayInfo(clReqParam: clReqParam)
        var trust = ""
        if clReqParam.token != nil {
            //            trust = getTrust(trust: getTrustString(salt: salt, token: clReqParam.token!), credType: clReqParam.flowType)
            
            
            trust = getTrust(salt: salt, token: clReqParam.token ?? "", flowType: clReqParam.flowType)
            
        }
        //TODO: Write details here for all the pending types -- And how to use this output for the final layer
        //        isCredentials = try clServices.getCredentialsPresented(from: <#T##UIViewController!#>, controls: <#T##[AnyHashable : Any]!#>, keyCode: <#T##String!#>, keyXMLPayload: <#T##String!#>, configuration: <#T##[AnyHashable : Any]!#>, salt: <#T##[AnyHashable : Any]!#>, trust: <#T##String!#>, payInfo: <#T##[Any]!#>, language: <#T##String!#>, completionHandler: <#T##((Int32, Error?, [AnyHashable : Any]?, ResponseBlock?) -> Void)!##((Int32, Error?, [AnyHashable : Any]?, ResponseBlock?) -> Void)!##(Int32, Error?, [AnyHashable : Any]?, ResponseBlock?) -> Void#>)
        //        clServices.getCredentialsPresented(from: controller, controls: UPIDataConverter().convertToDictionaryData(structInstance: control), keyCode: keyCode, keyXMLPayload: xmlPayload, configuration: configuration, salt: UPIDataConverter().convertToDictionaryData(structInstance: salt), trust: trust, payInfo: [payInfo], language: clReqParam.languagePref, completionHandler: { intData, errors, configData, responseFound in
        //            print(intData, errors, configData, responseFound)
        //        })
        
        
        //        CLServices.getCredentialsPresented(from: controller, controls: UPIDataConverter().convertToDictionaryData(structInstance: control), keyCode: keyCode, keyXMLPayload: xmlPayload, configuration: configuration, salt: UPIDataConverter().convertToDictionaryData(structInstance: salt), trust: trust, payInfo: [payInfo], language: clReqParam.languagePref, completionHandler: { intData, errors, configData, responseFound in
        //            print(intData, errors ?? "", configData ?? "", responseFound ?? "")
        //        })
        
        //        CLServices.getCredentialsPresented(from: controller, controls: control, keyCode: keyCode, keyXMLPayload: xmlPayload, configuration: configuration, salt: UPIDataConverter().convertToDictionaryData(structInstance: salt), trust: "[\"pay\":\"kpygOZuZJwApW0h7LwoLW4U4M0BFQuwPwHzP63tpxjCk1Q8s3iJbC8Wi+pfvd2x9\"]", payInfo: [payInfo], language: clReqParam.languagePref, completionHandler: { intData, errors, configData, responseFound in
        
        CLServices.getCredentialsPresented(from: controller, controls: control, keyCode: keyCode, keyXMLPayload: xmlPayload, configuration: configuration, salt: UPIDataConverter().convertToDictionaryData(structInstance: salt), trust: trust, payInfo: [payInfo], language: clReqParam.languagePref, completionHandler: { intData, errors, configData, responseFound in
            
            print(intData, errors ?? "", configData ?? "", responseFound ?? "")
        })
        return isCredentials // pending to return always true
    }
    
    /*
     * Get Configuration param
     */
    private func getConfigurationParam(clRequestParams: CLRequestParams) -> Dictionary<AnyHashable, Any> {
        let configuration = ConfigurationParams(payerBankName: clRequestParams.payerBankName,
                                                imageUrl: clRequestParams.imageUrl,
                                                resendAadhaarOTPFeature: clRequestParams.resendAadhaarOTPFeature,
                                                resendIssuerOTPFeature: clRequestParams.resendIssuerOTPFeature,
                                                issuerResendOTPLimit: clRequestParams.issuerResendOTPLimit,
                                                aadhaarResendOTPLimit: clRequestParams.aadhaarResendOTPLimit,
                                                verifiedMerchant: clRequestParams.verifiedMerchant,
                                                forgotUpiPINEnabled: clRequestParams.forgotUpiPINEnabled,
                                                captureCardDetails: clRequestParams.captureCardDetails,
                                                isAuthOffline: clRequestParams.isAuthOffline,
                                                enableUserAuth: clRequestParams.enableUserAuth,
                                                getDeviceDetails: clRequestParams.getDeviceDetails)
        return UPIDataConverter().convertToDictionaryData(structInstance: configuration)
    }
    
    /*
     * Get Salt value for credentials
     */
    private func getSaltParamString(clRequestParams: CLRequestParams) -> SaltParams { //Dictionary<AnyHashable, Any> {
        var transactionId = ""
        if clRequestParams.txnID?.count == 1 {
            transactionId = clRequestParams.txnID?[0] ?? ""
        } else {
            transactionId = "\(clRequestParams.txnID?[0] ?? ""),\(clRequestParams.txnID?[1] ?? "")"
        }
        let saltParamBuilder = SaltParams(txnId: [transactionId],
                                          txnAmount: clRequestParams.txnAmt!,
                                          deviceId: clRequestParams.deviceId,
                                          appId: clRequestParams.appId,
                                          mobileNumber: clRequestParams.mobileNo,
                                          credType: [clRequestParams.flowType],
                                          payerAddr: clRequestParams.payerAddress!,
                                          payeeAddr: clRequestParams.payerAddress!,
                                          random: RANDOM().random() ?? "")
        return saltParamBuilder //upiHelper.convertToDictionaryData(structInstance: saltParamBuilder)
    }
    
    /*
     * Get Trust value from salt
     *
     * a. Steps to generate Trust (mandatory field). Concatenate credType, transaction Id, app Id, mobile
     * number, device id, payer address, payee address and transaction amount with the separator "|".
     * b.16-byte random value created. This random will be added in salt json as base64 string in random field that is getSalt() method
     * c.Create a hash of the concatenated string using SHA-256 algorithm with random value. that is sha256Bytes method
     * d.Encrypt the hash with the token as key using AES-256 algorithm and random as iv parameter. that is aesEncrypt method
     *
     */
    
    private func getTrustString(salt: SaltParams, token: String) -> String {
        //        return TrustCreator().createTrust(message: salt.generateSalt(), token: token, random: upiHelper.random()!)
        //        pay|38ef20cc-508e-414a-b619-6e278702d0a9|com.montran.test|1234567890|android_id|testpay@upi.com|testpay2@upi.com|29.12
        let trustString = TRUST().generateCred(salt.generateSalt(), npciToken: token, random: RANDOM().random()) ?? ""
        return trustString //"7MaLBM+gjwBvSQ2+4xmzMv8n87ekSkXEnn5CmzFQe7zhb/PTs7xmFez162buMM5H"//trustString
    }
    
    //    salt.generateSalt()
    
    /*
     * Separate trust needs to be created for each credType and same has to be passed with the identified
     * credType by forming a JSON String
     * For example:
     * Trust="{\"pay\":\"trust_for_type_pay\",\"reqBalChk\":\"trust_for_type_reqBalChk\"}"
     */
    private func getTrust(salt: SaltParams,token: String, flowType: String) -> String {
        switch flowType {
        case FlowType().PAY_AND_REQ_BAL_CHK: // pending to new change
            let trust = [FlowType().PAY: "trust",
                         FlowType().REQ_BAL_CHK: "trust"]
            return trust.toJSONString()
            
        case FlowType().COLLECT_AND_REQ_BAL_CHK:
            let trust = [FlowType().COLLECT: "trust",
                         FlowType().REQ_BAL_CHK: "trust"]
            return trust.toJSONString()
        default:
            let trust = getTrustString(salt: salt, token: token)
            let convertTrust = "{\"\(salt.credType[0])\":\"\(trust)\"}" //[salt.credType.first: trust].toJSONString()// "{\"pay\":\"kpygOZuZJwApW0h7LwoLW4U4M0BFQuwPwHzP63tpxjCk1Q8s3iJbC8Wi+pfvd2x9\"}"
            //            let finaltrust = trust + convertTrust
            return convertTrust //trust.toJSONString()
        }
    }
    
    /*
     *
     * Get pay information json array string
     * @param clReqParam
     */
    
    public func getPayInfo(clReqParam: CLRequestParams) -> String {
        var payInfoArray: [[String: String]] = []
        if clReqParam.payeeName != nil {
            let payJson = ["name": "payeeName",
                           "value": clReqParam.payeeName!]
            payInfoArray.append(payJson)
        }
        
        if clReqParam.accountNo != nil {
            let accJson = ["name": "account",
                           "value": clReqParam.accountNo!]
            payInfoArray.append(accJson)
        }
        
        if clReqParam.mobileNo != "" {
            let mobileJson = ["name": "mobileNumber",
                              "value": clReqParam.mobileNo]
            payInfoArray.append(mobileJson)
        }
        
        if clReqParam.txnAmt != nil {
            let txnAmtJson = ["name": "txnAmount",
                              "value": clReqParam.txnAmt!]
            payInfoArray.append(txnAmtJson)
        }
        
        if clReqParam.note != nil {
            let noteJson = ["name": "note",
                            "value": clReqParam.note!]
            payInfoArray.append(noteJson)
        }
        
        if clReqParam.refId != nil {
            let refIdJson = ["name": "refId",
                             "value": clReqParam.refId!]
            payInfoArray.append(refIdJson)
        }
        
        if clReqParam.referenceWebUrl != nil {
            let refUrlJson = ["name": "refUrl",
                              "value": clReqParam.referenceWebUrl!]
            payInfoArray.append(refUrlJson)
        }
        
        return payInfoArray.toJSONString()
    }
}
